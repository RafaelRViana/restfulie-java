h1. Restfulie: quit pretending

CRUD through HTTP is a good step forward to using resources and becoming RESTful, another step further into it is to make use of hypermedia based services and this gem allows you to do it really fast.

You can read the "article on using the web for real":http://guilhermesilveira.wordpress.com/2009/11/03/quit-pretending-use-the-web-for-real-restfulie/ which gives an introduction to hypermedia/aware resources.

h2. Why would I use restfulie?

1. Easy --> writing hypermedia aware resource based clients
2. Easy --> hypermedia aware resource based services
3. Small -> it's not a bloated solution with a huge list of APIs
4. HATEOAS --> clients you are unaware of will not bother if you change your URIs
5. HATEOAS --> services that you consume will not affect your software whenever they change part of their flow or URIs

h2. Could you compare it with Spring or JAX-RS based APIs?

Restfulie is the first API which tries to somehow implement "Jim Webber":http://jim.webber.name/ and "Ian Robinson":http://iansrobinson.com/ opinion on how RESTFul systems use hypermedia
as the way to lead your client's path through a business process.

Therefore Restfulie is unique both in its feature set when compared to both Spring and JAX-RS based implementations, and its implementation: looking for simple code and favoring conventions over manual configurations.

According to "xxxxxx's model":http://www , systems are only to be called RESTFul if they support this kind of state flow transition through hypermedia content contained within resources representations:

<pre>
<order>
	<product>basic rails course</product>
	<product>RESTful training</product>
	<atom:link rel="refresh" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="update" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="pay" href="http://www.caelum.com.br/orders/1/pay" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="cancel" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
</order>
</pre>

If you are to implement a 3rd level (restful) service, Restfulie is the way to go. 

h2. Inner libraries

In its Java version, Restfulie uses by default but allows overriding:

* VRaptor:http://www.vraptor.org as the server-side controller  
* XStream:"http://xstream.codehaus.org" as its serialization library
* java.net api for http requests
* Spring IoC for dependency injection

XStream is the most famous java serialization tool around with support both to json and xml while VRaptor (as Rails) supplies a reverse URI lookup system upon its controller which provides a way to identify URI's from well defined transitions.

h2. Java or Ruby

Restfulie comes into different flavors, both "java":http://github.com/caelum/restfulie-java and "ruby":http://github.com/caelum/restfulie versions are available to use.

h1. One minute examples

h2. Client side

The client side code allows you to hide http-protocol specifics if required, while allowing you to re-configure it when needed.
Example on accessing a resource and its services through the restfulie API:

<pre>
Order order = new Order();

// place the order
order = service("http://www.caelum.com.br/order").post(order);

// cancels it
resource(order).getTransition("cancel").execute();
</pre>

h2. Server side

This is a simple example how to make your state changes available to your resource consumers:

<pre>
public class Order implements StateResource {

	public List<Transition> getFollowingTransitions(Restfulie control) {
		if (status.equals("unpaid")) {
			control.transition("latest").uses(OrderingController.class).get(this);
			control.transition("cancel").uses(OrderingController.class).cancel(this);
		}
		return control.getTransitions();
	}

}
</pre>

h1. Installation

h2. Client side installation

In order to use Restfulie in your client side app, simply add all required jars to your classpath.

h2. Server side installation

Download "vraptor's blank project":http://www.vraptor.org and add all server side jars to your application's classpath.

h1. Client side usage

The entry point for *Restfulie's* api is the *Restfulie* class. It's basic usage is through the *resource* method which, given an URI, will allow
you to retrieve a resource or post to a resource controller:

<pre>
  Order order = Restfulie.resource("http://www.caelum.com.br/orders/1").get();
  
  Client client = new Client();
  Restfulie.resource("http://www.caelum.com.br/clients").post(client);
</pre>

Due to the nature of the entry point and the java bytecode, Restfulie is still unable to allow the user to make the http verb even more transparent.

As seen earlier, as soon as you have aquired an object through the use of the restfulie api, you can invoke its transitions:

<pre>
Order order = Restfulie.resource("http://www.caelum.com.br/orders/1").get();
resource(order).getTransition("cancel").execute();
</pre>

The *resource* method can be statically imported from the *Restfulie* class.

h2. Serialization configuration

Restfulie uses XStream behind the scenes, therefore all XStream related annotations are supported by default when using it.
The following example shows how to alias a type:

<pre>
@XStreamAlias("order")
public class Order {
}
</pre>

More info on how to configure XStream through the use of annotations can be "found in its website":"http://xstream.codehaus.org".

By default, Restfulie serializes all primitive, String and enum types. In order to serialize child elements, one has pre-configure Restfulie. This is
the typical usage-pattern applications will face while using restfulie:

<pre>
Resources resources = Restfulie.resources();
resources.configure(Order.class).include("items");

// the configuration step is completed, so lets use it now:
resources.entryAt("http://www.caelum.com.br/clients").post(new Client());
</pre>












































<pre>
@Resource
public class OrderingController {

	private final Status status;
	private final OrderDatabase database;
	private final Routes routes;
	private final Result result;

	public OrderingController(Result result, Status status, OrderDatabase database, Routes routes) {
		// sets all fields
	}

	@Get
	@Path("/order/{order.id}")
	public void get(Order order) {
		order = database.getOrder(order.getId());
		result.use(xml()).from(order).include("items").serialize();
	}
	
	@Post
	@Path("/order")
	@Consumes("application/xml")
	public void add(Order order) {
		database.save(order);
		routes.uriFor(OrderingController.class).get(order);
		status.created(routes.getUri());
	}
	
	@Delete
	@Path("/order/{order.id}")
	@Transition
	public void cancel(Order order) {
		order = database.getOrder(order.getId());
		order.cancel();
		status.ok();
	}
	
}
</pre>

This is a simple example how to make your state changes available to your resource consumers:

<pre>
public class Order implements StateResource {

	public List<Transition> getFollowingTransitions(Restfulie control) {
		if (status.equals("unpaid")) {
			control.transition("latest").uses(OrderingController.class).get(this);
			control.transition("cancel").uses(OrderingController.class).cancel(this);
		}
		return control.getTransitions();
	}

}
</pre>






















The *pay* method shows another difference between JAX-RS and Restfulie: methods are allowed to have 


*Do not forget to create a migration with a string field named status for your resource:*

<pre>
scripts/generate migration add_status_to_order	
</pre>

Content:

<pre>
class AddStatusToOrder < ActiveRecord::Migration
  def self.up
    add_column :orders, :status, :string
	Order.all.each do |order|
		order.status = "unpaid"
		order.save
	end
  end

  def self.down
    remove_column :orders, :status
  end
end
</pre>

Or simply define a status reader and writer on your own.



h2. Help

If you are looking for or want to help, let us know at the mailing list:

"http://groups.google.com/group/restfulie":http://groups.google.com/group/restfulie

h2. Client-side configuration: how to customize your request

h3. HTTP verbs

By default, restfulie uses the following table:

* destroy, cancel and delete send a DELETE request
* update sends a PUT request
* refresh, reload, show, latest sends a GET request
* other methods sends a POST request

If you want to use a custom http verb in order to send your request, you can do it by setting the optional string 'method':

<pre>order.update(:method=>"post")</pre>

h3. Request parameters

If you want to send extra parameters, you can do it through the *data* parameter:

<pre>order.pay(:data => {:payment => my_payment})</pre>

The parameters will be serialized either to xml or json according to which format was used to deserialize the order at first place.

h3. Executing another GET request

If your method executes another GET request, it will automatically deserialize its result as:

<pre>order = Order.from_web order_uri
payment = order.check_payment_info</pre>

If you want to parse the response yourself, instead of receiving just the final deserialized object, you can do it by passing a body to your method

<pre>order = Order.from_web order_uri
successful = order.check_payment_info do |response|
  return response.code==200
end</pre>

h2. Server-side configuration

There are two different approaches that can be combined to create a full hypermedia aware resource based service, including awareness of its states and transitions.

h3. Simple usage: following transitions

The most easy way to use restfulie is to write the *following_transitions* method.
There are two easy steps to make it work:

1. Create your model (i.e. Order) with an *status* field
<pre>
script/generate scaffold Order status:string location:string
rake db:create
rake db:migrate
</pre>

Note that with this usage the status field is optional (from 0.3.0 onwards).

2. Add the *following_transitions* method returning an array of possible transitions:

<pre>
public class Order implements StateResource {

	private String id;
	private Location location;
	@XStreamImplicit
	private List<Item> items;

	private String status;
	private Payment payment;

	public enum Location {
		takeAway, drinkIn
	};

	public Order(String status, List<Item> items, Location location) {
		this.status = status;
		this.items = items;
		this.location = location;
	}

	public Order() {
	}
	
	// add id setter
	// add desired getters

	public List<Transition> getFollowingTransitions(Restfulie control) {
		if (status.equals("unpaid")) {
			control.transition("latest").uses(OrderingController.class).get(this);
			control.transition("cancel").uses(OrderingController.class).cancel(this);
			control.transition("pay").uses(OrderingController.class).pay(this,null);
		}
		return control.getTransitions();
	}

}</pre>

3. Update your *show* method within the *OrdersController* to show the hypermedia content:

<pre>
 def show
   @order = Order.find(params[:id])

   respond_to do |format|
     format.html # show.html.erb
     format.xml  { render :xml => @order.to_xml(:controller=>self) }
   end
 end
</pre>

You are ready to go, create a new order and save it into the database:

<pre>
	order = Order.new
	order.location = "take away"
	order.status = "unpaid"
	order.save
	puts "Order #{order.id} saved"
</pre>

Start up the server:

<pre>
	script/server
</pre>

And now access your server at http://localhost:3000/orders/1.xml

<pre>
<?xml version="1.0" encoding="UTF-8"?>
<order>
  <created-at>2009-11-23T00:15:15Z</created-at>
  <id>1</id>
  <location>take away</location>
  <status>unpaid</status>
  <updated-at>2009-11-23T00:15:15Z</updated-at>
  <atom:link rel="show" xmlns:atom="http://www.w3.org/2005/Atom" href="http://localhost:3000/orders/3"/>
</order>
</pre>

h3. Customizing the rel name

You can also override the action used, but still keep the rel

<pre>
def following_transitions
  transitions = []
  transitions << [:cancel, { :action => :destroy }]
  transitions
end
</pre>

Which will generate an hyperlink as

<pre><atom:link rel="cancel" rel="http://yourserver/orders/15" /></pre>

h3. Example

A full example showing all capabilities of this method follows:

<pre>
def following_transitions
  transitions = []
  transitions << [:show, {}]
  transitions << [:destroy, {}] if can_cancel?
  transitions << [:pay, {:id => id}] if can_pay?
  transitions << [:show, {:controller => :payments, :payment_id => payment.id }] if paid?
  transitions
end
</pre>

h3. Accessing all possible transitions

One can access all possible transitions for an object by invoking a resource's *getTransitions* method:

<pre>
	List<Transition> transitions = resource(order).getTransitions();
</pre>

h3. Checking the possibility of following transitions

By following the advanced usage, one receives also all *can_* method. i.e.:

<pre>
	order.status = :unpaid
	puts(order.can_pay?)              # will print true
	order.status = :paid
	puts(order.can_pay?)              # will print false
</pre>

You can use the *can_xxx* methods in your controllers to check if your current resource's state can be changed:

<pre>
def pay
  @order = Order.find(params[:id])
  raise "impossible to pay due to this order status #{order.status}" if !@order.can_pay?

  # payment code
end
</pre>
  
h3. Using xml+rel links instead of atom links

Atom is everywhere and can be consumed by a number of existing tools but if your system wants to supply its
services through commons rel+link xml as

<pre>
	<order>
		<product>basic rails course</product>
		<product>RESTful training</product>
		<refresh>http://www.caelum.com.br/orders/1</refresh>
		<update>http://www.caelum.com.br/orders/1</update>
		<pay>http://www.caelum.com.br/orders/1/pay</pay>
		<destroy>http://www.caelum.com.br/orders/1</destroy>
	</order>
</pre>

You can do it by passing the *use_name_based_link* argument:

<pre>
    order.to_xml(:controller => my_controller, :use_name_based_link => true)
</pre>

h2. Team

Restfulie was created and is maintained within Caelum by

Projetct Founder
* "Guilherme Silveira":http://guilhermesilveira.wordpress.com ( "email":mailto:guilherme.silveira@caelum.com.br )

Contributors
* Lucas Cavalcanti ("email":mailto:lucas.cavalcanti@caelum.com.br)
* Adriano Almeida ("email":mailto:adriano.almeida@caelum.com.br)

h3. Sources

You can see an application's source code here, both client and server side were implemented using *restfulie*:

"Client":http://github.com/caelum/restbook/chapter05/client
"Server":http://github.com/caelum/restbook/chapter05/server

h3. More tutorials

There is a "portuguese tutorial on the server-side support":http://wakethedead.com.br/blog/70-restfulie and a "blog post on the entire ecosystem in english":http://guilhermesilveira.wordpress.com/2009/11/03/quit-pretending-use-the-web-for-real-restfulie/


h2. What's new

h3. next release

* first java release (similar to 0.3 restfulie's ruby version)

h2. Coming soon

* javadoc
* release 0.3
* public cruise build
* routes.uriFor(OrderingController.class).get(order); status.created(routes.getUri()); should become status.created(order);
* release 0.4
* rel prepend suffix as http://iansrobinson.com/resources/link-relations/preceding
* automatically generate uri for this rel with its transition description
* pure href definition of link
* get entry point support
* Set the correct media type instead of application/xml
* full support to extended json
* allow servers to define transitions by accessing other systems
* allow servers to define a state method instead of internal variable
* controller filtering and methods
* english tutorial
* when receiving a 201 + content, it should believe the content
* when receiving a 201 without any content, it should allow to redirect or not
* client side should allow withTimeStamp, withETag, withAuth
* is there is an etag, use it by default (maybe NOT use it by default)... modified since and so on (header tags)
* server side maybe allow hypermedia controls or not

h2. Contributing

Users are encourajed to contribute with extra implementations for each layer (i.e. spring mvc implementation for the controller layer).

h2. License

Check the "license file":LICENSE